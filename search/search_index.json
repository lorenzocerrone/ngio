{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NGIO","text":"<p>NGIO is a Python library to streamline OME-Zarr image analysis workflows.</p> <p>Highlights:</p> <ul> <li>Abstract object base API for handling OME-Zarr files</li> <li>Validate OME-Zarr files</li> <li>Powefull iterators for reading and writing data using common access patterns</li> </ul>"},{"location":"#ngio-is-under-active-development","title":"\ud83d\udea7 Ngio is Under active Development \ud83d\udea7","text":""},{"location":"#roadmap","title":"Roadmap","text":"Feature Status ETA Description Metadata Handling \u2705 Read, Write, Validate OME-Zarr Metadata (0.4 supported, 0.5 ready) OME-Zarr Validation \u2705 Validate OME-Zarr files for compliance with the OME-Zarr Specification + Compliance between Metadata and Data Base Image Handling \u2705 Load data from OME-Zarr files, retrieve basic metadata, and write data ROI Handling \u2705 Common ROI models Label Handling \u2705 Mid-September Based on Image Handling Table Validation \u2705 Mid-September Validate Table fractal V1 + Compliance between Metadata and Data Table Handling \u2705 Mid-September Read, Write ROI, Features, and Masked Tables Basic Iterators Ongoing End-September Read and Write Iterators for common access patterns Base Documentation Ongoing End-September API Documentation and Examples Beta Ready Testing Ongoing End-September Beta Testing; Library is ready for testing, but the API is not stable Mask Iterators Ongoing October Iterators over Masked Tables Advanced Iterators Not started October Iterators for advanced access patterns Parallel Iterators Not started End of the Year Concurrent Iterators for parallel read and write Full Documentation Not started End of the Year Complete Documentation Release 1.0 (Commitment to API) Not started End of the Year API is stable; breaking changes will be avoided"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>As of now, the library is not available on PyPI. You can install it from the source code.</p> <pre><code>git clone git@github.com:fractal-analytics-platform/ngio.git\npip install \".[v2]\"\n</code></pre>"},{"location":"api/core/","title":"ngio.core","text":"<p>Core classes for the ngio library.</p>"},{"location":"api/core/#ngffimage","title":"NGFFImage","text":"<p>A class to handle OME-NGFF images.</p> Source code in <code>ngio/core/ngff_image.py</code> <pre><code>class NgffImage:\n    \"\"\"A class to handle OME-NGFF images.\"\"\"\n\n    def __init__(self, store: StoreLike) -&gt; None:\n        \"\"\"Initialize the NGFFImage in read mode.\"\"\"\n        self.store = store\n        self.group = open_group_wrapper(store=store, mode=\"r+\")\n        self._image_meta = get_ngff_image_meta_handler(\n            self.group, meta_mode=\"image\", cache=False\n        )\n\n        self.table = TableGroup(self.group)\n        self.label = LabelGroup(self.group, image_ref=self.get_image())\n\n    @property\n    def image_meta(self) -&gt; ImageMeta:\n        \"\"\"Get the image metadata.\"\"\"\n        return self._image_meta.load_meta()\n\n    @property\n    def num_levels(self) -&gt; int:\n        \"\"\"Get the number of levels in the image.\"\"\"\n        return self.image_meta.num_levels\n\n    @property\n    def levels_paths(self) -&gt; list[str]:\n        \"\"\"Get the paths of the levels in the image.\"\"\"\n        return self.image_meta.levels_paths\n\n    def get_image(\n        self,\n        *,\n        path: str | None = None,\n        pixel_size: PixelSize | None = None,\n        highest_resolution: bool = True,\n    ) -&gt; Image:\n        \"\"\"Get an image handler for the given level.\n\n        Args:\n            path (str | None, optional): The path to the level.\n            pixel_size (tuple[float, ...] | list[float] | None, optional): The pixel\n                size of the level.\n            highest_resolution (bool, optional): Whether to get the highest\n                resolution level\n\n        Returns:\n            ImageHandler: The image handler.\n        \"\"\"\n        if path is not None or pixel_size is not None:\n            highest_resolution = False\n\n        return Image(\n            store=self.group,\n            path=path,\n            pixel_size=pixel_size,\n            highest_resolution=highest_resolution,\n        )\n\n    def _update_omero_window(self) -&gt; None:\n        \"\"\"Update the OMERO window.\"\"\"\n        meta = self.image_meta\n        image = self.get_image(highest_resolution=True)\n        max_dtype = np.iinfo(image.array.dtype).max\n        start, end = image.dask_array.min().compute(), image.dask_array.max().compute()\n\n        channel_list = meta.omero.channels\n\n        new_channel_list = []\n        for channel in channel_list:\n            channel.extra_fields[\"window\"] = {\n                \"start\": start,\n                \"end\": end,\n                \"min\": 0,\n                \"max\": max_dtype,\n            }\n            new_channel_list.append(channel)\n\n        meta.omero.channels = new_channel_list\n        self._image_meta.write_meta(meta)\n\n    def derive_new_image(\n        self,\n        store: StoreLike,\n        name: str,\n        overwrite: bool = True,\n        **kwargs,\n    ) -&gt; \"NgffImage\":\n        \"\"\"Derive a new image from the current image.\n\n        Args:\n            store (StoreLike): The store to create the new image in.\n            name (str): The name of the new image.\n            overwrite (bool): Whether to overwrite the image if it exists\n            **kwargs: Additional keyword arguments.\n                Follow the same signature as `create_empty_ome_zarr_image`.\n\n        Returns:\n            NgffImage: The new image.\n        \"\"\"\n        image_0 = self.get_image(highest_resolution=True)\n\n        default_kwargs = {\n            \"store\": store,\n            \"shape\": image_0.on_disk_shape,\n            \"chunks\": image_0.array.chunks,\n            \"dtype\": image_0.array.dtype,\n            \"on_disk_axis\": image_0.dataset.on_disk_axes_names,\n            \"pixel_sizes\": image_0.pixel_size,\n            \"xy_scaling_factor\": self.image_meta.xy_scaling_factor,\n            \"z_scaling_factor\": self.image_meta.z_scaling_factor,\n            \"time_spacing\": image_0.dataset.time_spacing,\n            \"time_units\": image_0.dataset.time_axis_unit,\n            \"num_levels\": self.num_levels,\n            \"name\": name,\n            \"channel_labels\": image_0.channel_labels,\n            \"channel_wavelengths\": None,\n            \"channel_kwargs\": None,\n            \"omero_kwargs\": None,\n            \"overwrite\": overwrite,\n            \"version\": self.image_meta.version,\n        }\n\n        default_kwargs.update(kwargs)\n\n        create_empty_ome_zarr_image(\n            **default_kwargs,\n        )\n        return NgffImage(store=store)\n</code></pre>"},{"location":"api/core/#ngio.core.NgffImage.image_meta","title":"<code>image_meta: ImageMeta</code>  <code>property</code>","text":"<p>Get the image metadata.</p>"},{"location":"api/core/#ngio.core.NgffImage.levels_paths","title":"<code>levels_paths: list[str]</code>  <code>property</code>","text":"<p>Get the paths of the levels in the image.</p>"},{"location":"api/core/#ngio.core.NgffImage.num_levels","title":"<code>num_levels: int</code>  <code>property</code>","text":"<p>Get the number of levels in the image.</p>"},{"location":"api/core/#ngio.core.NgffImage.__init__","title":"<code>__init__(store)</code>","text":"<p>Initialize the NGFFImage in read mode.</p> Source code in <code>ngio/core/ngff_image.py</code> <pre><code>def __init__(self, store: StoreLike) -&gt; None:\n    \"\"\"Initialize the NGFFImage in read mode.\"\"\"\n    self.store = store\n    self.group = open_group_wrapper(store=store, mode=\"r+\")\n    self._image_meta = get_ngff_image_meta_handler(\n        self.group, meta_mode=\"image\", cache=False\n    )\n\n    self.table = TableGroup(self.group)\n    self.label = LabelGroup(self.group, image_ref=self.get_image())\n</code></pre>"},{"location":"api/core/#ngio.core.NgffImage.derive_new_image","title":"<code>derive_new_image(store, name, overwrite=True, **kwargs)</code>","text":"<p>Derive a new image from the current image.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>StoreLike</code> <p>The store to create the new image in.</p> required <code>name</code> <code>str</code> <p>The name of the new image.</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the image if it exists</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments. Follow the same signature as <code>create_empty_ome_zarr_image</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NgffImage</code> <code>NgffImage</code> <p>The new image.</p> Source code in <code>ngio/core/ngff_image.py</code> <pre><code>def derive_new_image(\n    self,\n    store: StoreLike,\n    name: str,\n    overwrite: bool = True,\n    **kwargs,\n) -&gt; \"NgffImage\":\n    \"\"\"Derive a new image from the current image.\n\n    Args:\n        store (StoreLike): The store to create the new image in.\n        name (str): The name of the new image.\n        overwrite (bool): Whether to overwrite the image if it exists\n        **kwargs: Additional keyword arguments.\n            Follow the same signature as `create_empty_ome_zarr_image`.\n\n    Returns:\n        NgffImage: The new image.\n    \"\"\"\n    image_0 = self.get_image(highest_resolution=True)\n\n    default_kwargs = {\n        \"store\": store,\n        \"shape\": image_0.on_disk_shape,\n        \"chunks\": image_0.array.chunks,\n        \"dtype\": image_0.array.dtype,\n        \"on_disk_axis\": image_0.dataset.on_disk_axes_names,\n        \"pixel_sizes\": image_0.pixel_size,\n        \"xy_scaling_factor\": self.image_meta.xy_scaling_factor,\n        \"z_scaling_factor\": self.image_meta.z_scaling_factor,\n        \"time_spacing\": image_0.dataset.time_spacing,\n        \"time_units\": image_0.dataset.time_axis_unit,\n        \"num_levels\": self.num_levels,\n        \"name\": name,\n        \"channel_labels\": image_0.channel_labels,\n        \"channel_wavelengths\": None,\n        \"channel_kwargs\": None,\n        \"omero_kwargs\": None,\n        \"overwrite\": overwrite,\n        \"version\": self.image_meta.version,\n    }\n\n    default_kwargs.update(kwargs)\n\n    create_empty_ome_zarr_image(\n        **default_kwargs,\n    )\n    return NgffImage(store=store)\n</code></pre>"},{"location":"api/core/#ngio.core.NgffImage.get_image","title":"<code>get_image(*, path=None, pixel_size=None, highest_resolution=True)</code>","text":"<p>Get an image handler for the given level.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | None</code> <p>The path to the level.</p> <code>None</code> <code>pixel_size</code> <code>tuple[float, ...] | list[float] | None</code> <p>The pixel size of the level.</p> <code>None</code> <code>highest_resolution</code> <code>bool</code> <p>Whether to get the highest resolution level</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ImageHandler</code> <code>Image</code> <p>The image handler.</p> Source code in <code>ngio/core/ngff_image.py</code> <pre><code>def get_image(\n    self,\n    *,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    highest_resolution: bool = True,\n) -&gt; Image:\n    \"\"\"Get an image handler for the given level.\n\n    Args:\n        path (str | None, optional): The path to the level.\n        pixel_size (tuple[float, ...] | list[float] | None, optional): The pixel\n            size of the level.\n        highest_resolution (bool, optional): Whether to get the highest\n            resolution level\n\n    Returns:\n        ImageHandler: The image handler.\n    \"\"\"\n    if path is not None or pixel_size is not None:\n        highest_resolution = False\n\n    return Image(\n        store=self.group,\n        path=path,\n        pixel_size=pixel_size,\n        highest_resolution=highest_resolution,\n    )\n</code></pre>"}]}